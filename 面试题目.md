# 面试题目
## 第一部分 mysql
### 1 mysql优化措施
#### 1.1 开发优化
增加缓存
主从复制，读写分离，分库分表
#### 1.1.1 SQL执行频次
```mysql
SHOW GLOBAL STATUS LIKE 'Com_______'; 
# 查看当前数据库的INSERT、UPDATE、DELETE、SELECT的访问频次
```
#### 1.1.2慢查询日志
```mysql
# 慢查询日志记录了所有执行时间超过指定参数（long_query_time，单位：秒，默认10秒）的所有SQL语句的日志。
# MySQL的慢查询日志默认没有开启，我们可以查看一下系统变量 slow_query_log。
# 如果要开启慢查询日志，需要在MySQL的配置文件（/etc/my.cnf）中配置如下信息
# 开启MySQL慢日志查询开关 
slow_query_log=1 
# 设置慢日志的时间为2秒，SQL语句执行时间超过2秒，就会视为慢查询，记录慢查询日志 
long_query_time=2 
# 配置完毕之后，通过以下指令重新启动MySQL服务器进行测试，查看慢日志文件中记录的信息
# /var/lib/mysql/localhost-slow.log。

```
#### 1.1.3profile详情
```mysql
show profiles 
#     能够在做SQL优化时帮助我们了解时间都耗费到哪里去了。通过have_profiling参数，能够看到当前MySQL是否支持profile操作：
SELECT @@have_profiling ; 
# 可以通过set语句在session/global级别开启profiling：
SET profiling = 1; 
# 查看每一条SQL的耗时基本情况 
show profiles; 
# 查看指定query_id的SQL语句各个阶段的耗时情况 
show profile for query 【query_id】;
# 查看指定query_id的SQL语句CPU的使用情况 
show profile cpu for query 【query_id】;
```

#### 1.1.4explain
EXPLAIN 或者 DESC命令获取 MySQL 如何执行 SELECT 语句的信息，包括在 SELECT 语句执行过程中表如何连接和连接的顺序。
<img src=".面试题目_images/20ebc9ca.png"/>
<img src=".面试题目_images/7cc9651f.png"/>
<img src=".面试题目_images/71571e26.png"/>
1. 插入数据时\
批量插入数据时，保证主键顺序插入防止页分裂现象，同时手动控制事务。
大批量插入数据时\
可用load infile，当然这要求我们在连接数据库时使用参数local infile
并set global local_infile = 1。
2. 主键\
主键自增，不要修改，降低主键长度，尽量不要使用UUID
3. 查询\
3.1 索引\
1). 针对于数据量较大，且查询比较频繁的表建立索引。
2). 针对于常作为查询条件（where）、排序（order by）、分组（group by）操作的字段建立索引。
3). 尽量使用联合索引，减少单列索引，查询时，联合索引很多时候可以覆盖索引，节省存储空间，避免回表，提高查询效率。
4). 查询时，尽量使用覆盖索引，而不是select *, 避免返回不必要的数据。\
5). 适当分批量进行
3.2 limit\
一般分页查询时，通过创建覆盖索引能够比较好地提高性能，可以通过覆盖索引加子查询形式进行优化。
 select * from tb_sku t , (select id from tb_sku order by id limit 2000000,10) a where t.id = a.id;
3.3count\
<img src="C:\Users\32818\Desktop\数据分析\图片\63005e3a-7c06-4b59-8649-53648edba391-15066759.jpg"/>


### 2 mysql去重
1.窗口函数用 主键+倒序时间戳row_number=1去重 
```mysql
-- 在支持窗口函数的 sql 中使用
select count(case when rn=1 then task_id else null end) task_num
from (select task_id
       , row_number() over (partition by task_id order by start_time) rn
   from Task) tmp;
```
2.distinct 如果 DISTINCT 关键字后有多个字段，则会对多个字段进行组合去重
3.union 
4.order by + group by / group by 本身
```mysql
SELECT
	id,
	product_id,
	product_name,
	product_logo,
	product_english_name,
	product_type,
	browse_time,
	user_id,
	del_flag 
FROM
	pm_browse_history_info 
WHERE
	browse_time in ( SELECT MAX( browse_time ) FROM pm_browse_history_info 
	                                           WHERE del_flag = '0' AND user_id = '1' GROUP BY product_id ) 
ORDER BY
	browse_time DESC
```
### 3 drop、truncate、delete的区别
1.truncate 和不带 where 子句的 delete、以及 drop 都会删除表内的数据，
但是truncate 和 delete 只删除数据不删除表的结构(定义)，执行drop语句，此表的结构也会删除，也就是执行 drop 之后对应的表不复存在。\

2.truncate和drop 属于DDL(数据定义语言)语句，操作立即生效，原数据不放到 rollback segment 中，不能回滚，
操作不触发 trigger。而 delete 语句是DML (数据库操作语言)语句，这个操作会放到 rollback segement 中，事务提交之后才生效。

3.执行速度上drop>truncate>delete

### 4 补充索引知识点
<img src=".面试题目_images/793e14f3.png"/>
<img src=".面试题目_images/c67ebadb.png"/>
#### 4.1 索引失效情况\
1.or连接条件，如果前面字段有索引后面没有就会失效， 解决方式使用union
2.字段类型是字符串，where时一定用引号括起来，否则索引失效
3.模糊匹配时，如果仅仅是尾部模糊匹配，索引不会失效。如果是头部模糊匹配，索引失效
4.联合索引，查询时的条件列不是联合索引中的第一个列，索引失效
5.索引列运算，不论是select后还是where后的列运算，都会导致索引失效
6.mysql估计使用全表扫描要比使用索引快,则不使用索引， 例子 is null 与 is not null

#### 4.2 索引规则\
#### 4.2.1 覆盖索引
覆盖索引是指查询使用了索引，并且需要返回的列，在该索引中已经全部能够找到。
#### 4.2.2 回表查询
这种先到二级索引中查找数据，找到主键值，然后再到聚集索引中根据主键值，获取数据的方式，就称之为回表查询。
<img src=".面试题目_images/258efa82.png"/>
一个表中只能拥有一个聚集索引，而非聚集索引一个表可以存在多个。\
聚集索引：物理存储按照索引排序；非聚集索引：物理存储不按照索引排序；
#### 4.2.3 B树与B+树结构
<img src=".面试题目_images/8c88bb85.png"/>
B-Tree，B树是一种多叉路衡查找树，相对于二叉树，B树每个节点可以有多个分支，即多叉。
以一颗最大度数（max-degree）为5(5阶)的b-tree为例，那这个B树每个节点最多存储4个key，5个指针。
<img src=".面试题目_images/d1db38a3.png"/>
##### 特点
5阶的B树，每一个节点最多存储4个key，对应5个指针。
一旦节点存储的key数量到达5，就会裂变，中间元素向上分裂。
在B树中，非叶子节点和叶子节点都会存放数据。

B+Tree是B-Tree的变种
<img src=".面试题目_images/517fe5aa.png"/>
##### 特点
所有的数据都会出现在叶子节点。
叶子节点形成一个单向链表。
非叶子节点仅仅起到索引数据作用，具体的数据都是在叶子节点存放的。

##### 区别
B+树内节点不存储数据，所有 data 存储在叶节点导致查询时间复杂度固定为 log n。而B-树查询时间复杂度不固定，与 key 在树中的位置有关，最好为O(1)。\
B+树叶节点两两相连可大大增加区间访问性，可使用范围查询等，减少磁盘IO，而B-树每个节点 key 和 data 在一起，则无法区间查找。\
由于B树的节点都存了key和data，而B+树只有叶子节点存data，非叶子节点都只是索引值，没有实际的数据，这就时B+树在一次IO里面，能读出的索引值更多。从而减少查询时候需要的IO次数！
#### 4.2.4 最左前缀法则
最左前缀法则指的是查询从索引的最左列开始，并且不跳过索引中的列。如果跳跃某一列，索引将会部分失效(后面的字段索引失效)。与我们编写SQL时，条件编写的先后顺序无关。

#### 4.2.5索引下推
索引下推优化是 MySQL 5.6 引入的， 可以在索引遍历过程中，对索引中包含的字段先做判断，直接过滤掉不满足条件的记录，减少回表次数。
我们执行 select * from T where name like '张%' and age=10 and ismale=1;语句，我们已经知道了B-tree 索引的最左前缀原则，所以将会用到 name_age 索引，因为索引下推优化，会在 name_age 索引树上判断 name 和 age 是否满足。
根据我们上面的执行语句，会在 name_age 索引树上查找 name 以 '张' 开头的并且 age = 10 的数据，然后在回到主键索引树中查询所需要的信息，并不是所有 name_age 索引树上查找 name 以 '张' 开头的数据都回主键索引树中查询数据，这样就减少了一些不必要的查询。

### 5 InnoDB与MyISAM的区别
1.InnoDB支持事务，MyISAM不支持事务

2.InnoDB支持外键，MyISAM不支持外键

3.InnoDB 支持 MVCC(多版本并发控制)，MyISAM 不支持

4.select count(*) from table时，MyISAM更快，因为它有一个变量保存了整个表的总行数，可以直接读取，InnoDB就需要全表扫描。

5.InnoDB支持表、行级锁，而MyISAM支持表级锁。

6.InnoDB表必须有主键，而MyISAM可以没有主键

### 6 limit 1000000 加载很慢的话，你是怎么解决的呢？
方案一：如果id是连续的，可以这样，返回上次查询的最大记录(偏移量)，再往下limit

select id，name from employee where id>1000000 limit 10.

方案二：在业务允许的情况下限制页数：

建议跟业务讨论，有没有必要查这么后的分页啦。因为绝大多数用户都不会往后翻太多页。

方案三：order by + 索引（id为索引）

select id，name from employee order by id limit 1000000，10

方案四：利用延迟关联或者子查询优化超多分页场景。（先快速定位需要获取的id段，然后再关联）

SELECT a.* FROM employee a, (select id from employee where 条件 LIMIT 1000000,10 ) b where a.id=b.id


### 7 事务相关
事务是一组操作的集合，它是一个不可分割的工作单位，事务会把所有的操作作为一个整体一起向系统提交或撤销操作请求，即这些操作要么同时成功，要么同时失败。
#### 7.1 事务的特性
原子性（Atomicity）：事务是不可分割的最小操作单元，要么全部成功，要么全部失败。\
原理：是使用 undo log来实现的，如果事务执行过程中出错或者用户执行了rollback，系统通过undo log日志返回事务开始的状态。另一个作用是MVCC。

一致性（Consistency）：事务完成时，必须使所有的数据都保持一致状态。\
原理：通过回滚、恢复，以及并发情况下的隔离性，从而实现一致性。(redo log + undo log共同保证)

隔离性（Isolation）：数据库系统提供的隔离机制，保证事务在不受外部并发操作影响的独立环境下运行。\
原理：锁+MVCC(多版本并发控制)
MVCC原理：
全称 Multi-Version Concurrency Control，多版本并发控制。指维护一个数据的多个版本，使得读写操作没有冲突，快照读为MySQL实现MVCC提供了一个非阻塞读功能。MVCC的具体实现，还需要依赖于数据库记录中的三个隐式字段、undo log日志、readView。 

0、当前读与快照读
当前读：读取的是记录的最新版本，读取时还要保证其他并发事务不能修改当前记录，会对读取的记录进行加锁。
快照读：简单的select（不加锁）就是快照读，快照读，读取的是记录数据的可见版本，有可能是历史数据，不加锁，是非阻塞读。

1、隐藏字段 - 在ibd文件中
<img src=".面试题目_images/14b82e4a.png"/>

2、undo log 日志
<img src=".面试题目_images/7fd5c96c.png"/>
最终我们发现，不同事务或相同事务对同一条记录进行修改，会导致该记录的undolog生成一条记录版本链表，链表的头部是最新的旧记录，链表尾部是最早的旧记录。

3、readview
ReadView（读视图）是 快照读 SQL执行时MVCC提取数据的依据，记录并维护系统当前活跃的事务（未提交的）id。
<img src=".面试题目_images/4c3a0624.png"/>
而在readview中就规定了版本链数据的访问规则：trx_id 代表当前undolog版本链对应事务ID。

访问规则
<img src=".面试题目_images/032cc42d.png"/>
READ COMMITTED ：在事务中每一次执行快照读时生成ReadView。
REPEATABLE READ：仅在事务中第一次执行快照读时生成ReadView，后续复用该ReadView。 


持久性（Durability）：事务一旦提交或回滚，它对数据库中的数据的改变就是永久的。\
原理：redo log, 重做日志缓冲（redo log buffer）以及重做日志文件（redo log file）,前者是在内存中，后者在磁盘中。
当事务提交之后会把所有修改信息都存到该日志文件中, 用于在刷新脏页到磁盘,发生错误时, 进行数据恢复使用。
#### 7.2 并发事务问题
1、脏读 - 一个事务读到另外一个事务还没有提交的数据
<img src=".面试题目_images/96321c86.png"/>
2、不可重复读 - 一个事务先后读取同一条记录，但两次读取的数据不同，称之为不可重复读。
<img src=".面试题目_images/3c0f51fc.png"/>
3、幻读 - 一个事务按照条件查询数据时，没有对应的数据行，但是在插入数据时，又发

现这行数据已经存在，好像出现了 "幻影"。
<img src=".面试题目_images/ccc3eaf4.png"/>

#### 7.3 事务隔离级别

<img src=".面试题目_images/baa63dde.png"/>

```mysql
SET [ SESSION | GLOBAL ] TRANSACTION ISOLATION LEVEL { READ UNCOMMITTED |READ COMMITTED | REPEATABLE READ | SERIALIZABLE }
```

### 8 锁 - 锁是计算机协调多个进程或线程并发访问某一资源的机制
#### 8.1锁粒度 - 行锁，表锁，全局锁 / 锁模式 - 元数据锁？，意向锁，gap锁，临键锁
1. 全局锁 - 全局锁就是对整个数据库实例加锁，加锁后整个实例就处于只读状态。 数据库备份
2. 表锁(表锁，元数据锁，意向锁)\
2.1 表锁 - 读锁(限制其他事务写)， 写锁(限制其他事务所有操作) lock tables 表名... read/write。\
2.2 元数据锁 - 系统自动控制 - 为了避免DML与DDL冲突，保证读写的正确性。
   <img src=".面试题目_images/4a487e69.png"/>
当对一张表进行增删改查的时候，加MDL读锁(共享)；当对表结构进行变更操作的时候，加MDL写锁(排他)。\
2.3 意向锁 - 为了避免DML在执行时，加的行锁与表锁的冲突，在InnoDB中引入了意向锁，使得表锁不用检查每行数据是否加锁，使用意向锁来减少表锁的检查。意向共享锁(IS): 由语句select ... lock in share mode添加 。 与 表锁共享锁(read)兼容，与表锁排他锁(write)互斥。
意向排他锁(IX): 由insert、update、delete、select...for update添加 。与表锁共享锁(read)及排他锁(write)都互斥，意向锁之间不会互斥。
一旦事务提交了，意向共享锁、意向排他锁，都会自动释放。\
2.4 特点：开销小，加锁快；锁定力度大，发生锁冲突概率高，并发度最低;不会出现死锁。

3. 行锁(行锁， 间隙锁， 临键锁) - 基于索引实现的，如果没有索引会升级成表锁
3.1 行锁 锁定单个行记录的锁，防止其他事务对此行进行update和delete。在RC、RR隔离级别下都支持。\
3.2 间隙锁 锁定索引记录间隙（不含该记录），确保索引记录间隙不变，防止其他事务在这个间隙进行insert，产生幻读。在RR隔离级别下都支持。\
3.3 临键锁 行锁和间隙锁组合，同时锁住数据，并锁住数据前面的间隙Gap。在RR隔离级别下支持。\
3.4 行锁类型： 共享锁（S）：允许一个事务去读一行，阻止其他事务获得相同数据集的排它锁。 排他锁（X）：允许获取排他锁的事务更新数据，阻止其他事务获得相同数据集的共享锁和排他锁。
   <img src=".面试题目_images/81b771a1.png"/>
   <img src=".面试题目_images/249fa991.png"/>
3.4特点：开销大，加锁慢；会出现死锁；锁定粒度小，发生锁冲突的概率低，并发度高。
4. RC 和 RR 与 锁 select ... lock in share mode\
RC隔离级别下，加锁的select, update, delete等语句，使用的是记录锁，其他事务的插入依然可以执行，因此会存在幻读~
RR隔离级别下，加锁的select, update, delete等语句，会使用间隙锁+ 临键锁，锁住索引记录之间的范围，避免范围间插入记录，以避免产生幻影行记录。

#### 8.3 死锁
mysql死锁是指两个或多个事务在同一资源上相互占用,并请求锁定对方占用的资源,从而导致恶性循环。\
InnoDB存储引擎能检测到死锁的循环依赖并立即返回一个错误。只有部分或完全回滚其中一个事务,才能打破死锁。 \
死锁有四个必要条件：互斥条件，请求和保持条件，环路等待条件，不剥夺条件。\
解决方案：
如果不同程序会并发存取多个表，尽量约定以相同的顺序访问表，可以大大降低死锁机会。

在同一个事务中，尽可能做到一次锁定所需要的所有资源，减少死锁产生概率；

对于非常容易产生死锁的业务部分，可以尝试使用升级锁定颗粒度，通过表级锁定来减少死锁产生的概率；

如果业务处理不好可以用分布式事务锁或者使用乐观锁

死锁与索引密不可分，解决索引问题，需要合理优化你的索引，


#### 8.4加锁机制 - 悲观锁与乐观锁
悲观锁：假定会发生并发冲突，在该用户读取数据的期间，其他任何用户都不能来修改该数据，但是其他用户是可以读取该数据的，只有当自己读取完毕才释放锁。Repeatable Read

数据库中的行锁，表锁，读锁，写锁，以及syncronized实现的锁均为悲观锁。

乐观锁认为数据的变动不会太频繁。因此，它允许多个事务同时对数据进行变动。
乐观锁通常是通过在表中增加一个版本(version)或时间戳(timestamp)来实现，其中，版本最为常用，即在表中多增加一个字段。


### 9 select for update有什么含义，会锁表还是锁行还是其他
select查询语句是不会加锁的，但是select for update除了有查询的作用外，还会加锁呢，而且它是悲观锁哦。至于加了是行锁还是表锁，这就要看是不是用了索引/主键啦。

没用索引/主键的话就是表锁，否则就是是行锁。(InnoDB的行锁是针对于索引加的锁，不通过索引条件检索数据，那么InnoDB将对表中的所有记录加锁，此时就会升级为表锁。)


### 10 SQL执行顺序
DQL语句
from join on where group by having select order by limit
客户端 - 连接器(检查是否有权限) - 查询缓存(no, 8.0后删除了) - 分析器(是否出错) - 优化器 - 执行器

### 11 谈谈三大范式
第一范式（1NF）
    是指数据库表的每一列都是不可分割的基本数据项，第一范式就是无重复的列。强调的是列的原子性。

第二范式（2NF）
    满足第二范式（2NF）必须先满足第一范式（1NF）。另外包含两部分内容，一是表必须有主键；二是没有包含在主键中的列必须完全依赖于主键，而不能只依赖于主键的一部分。

第三范式（3NF）
    满足第三范式（3NF）必须先满足第二范式（2NF）第三范式就是属性不依赖于其它非主属性。非主键列必须直接依赖于主键，不能存在传递依赖。

换一种理解
    1NF：字段是最小的的单元不可再分
    2NF：满足1NF，表中的字段必须完全依赖于全部主键而非部分主键
    3NF：满足2NF， 非主键外的所有字段必须互不依赖
    BCNF：满足3NF，消除主属性对码的部分和传递依赖
    4NF：满足BCNF，消除表中的多值依赖

### 12 In和exist
In 是先执行in的语句，然后再执行主表的语句，适用于主表大的\
exist是先执行主查询，再将主查询的语句放到子查询中做验证条件， 适用于子表大的\
如果使用的是not in与not exists，直接使用not exists，因为not in 会进行全表扫描不走索引，not exists会走索引。

### 13 InnoDB存储引擎的四大特性
1.插入缓冲\
    在insert数据时，如果该数据的非聚集索引页存在于缓冲池中，那么就直接插入到索引页中，如果不存在，则插入到insert buffer中，然后按照一定的频率进行合并操作，写入磁盘，

2.二次写\
    当页需要写回数据库时，首先把页备份到内存中的doublewrite buffer，然后每次1M，写入到共享表空间中，共享表空间也是在磁盘上，然后再将这些页写入到真的数据文件中，就算这个时候服务器出了问题，也是可以用共享表空间中的数据进行还原

3.自适应哈希索引\
    自适应hash索引，用于优化对Buffer Pool数据的查询,果观察到在特定的条件下hash索引可以提升速度，则建立hash索引，称之为自适应hash索引。

4.预读\
    innodb中将64个页划分为一个extent，当一个extent中的页，被顺序读超过了多少个，比如50个，那么就会认为顺序读到下一个extent的可能性很大，


### 14 mysql数据类型
14.1 数值型
<img height="140" src=".面试题目_images/a649c5c6.png" width="600"/>

14.2 字符串
<img src=".面试题目_images/328bc460.png"/>

14.3 日期类型
<img src=".面试题目_images/87a4bef8.png"/>
### 3.有哪些窗口函数？聚合函数用作窗口函数和普通的聚合函数有什么区别？

### 15 SQL约束类型

<img src=".面试题目_images/66f32b28.png"/>

### 16 什么是游标？
游标是用来存储查询结果集的数据类型 , 在存储过程和函数中可以使用游标对结果集进行循环的处理。游标的使用包括游标的声明declare cursor for、OPEN、FETCH 和 CLOSE.

### 17 存储过程
存储过程是事先经过编译并存储在数据库中的一段 SQL 语句的集合，调用存储过程可以简化应用开发人员的很多工作，减少数据在数据库和应用服务器之间的传输，对于提高数据处理的效率是有好处的。
存储过程思想上很简单，就是数据库 SQL 语言层面的代码封装与重用
create procedure(in out inout)
begin
    sql
end
封装，复用 可以接收参数，也可以返回数据 减少网络交互，效率提升
while do
repeat until end repeat
loop end loop
调试麻烦，可移植性不强

### 18 触发器
触发器是与表有关的数据库对象，指在insert/update/delete之前(BEFORE)或之后(AFTER)，触发并执行触发器中定义的SQL语句集合。触发器的这种特性可以协助应用在数据库端确保数据的完整性, 日志记录 , 数据校验等操作 。

可以通过数据库中的相关表实现级联更改。

实时监控某张表中的某个字段的更改而需要做出相应的处理。

例如可以生成某些业务的编号。
<img src=".面试题目_images/b1a7d129.png"/>
### 4.3个排序函数的区别？
ROW_NUMBER()函数会依次进行排序且序号不相同

RANK()函数会依次排序如结果一样序号相同且会跳跃排名

DENSE_RANK()会依次排序如结果一样序号相同且不会跳跃排名









## 第二部分 python
### 1XGB原理
